In this MPC project I am trying to control the behavior of the car in order for it to complete a full lap of the track under the full autonomous control of the Model predictive control program that I have written.  Below I will discuss some of the details of the MPC program that I have written.

First it is important to talk about what the model does and to do this I will need to discuss these three areas of the model: the state, actuators, and update equations.  The state is where we store the current six state variables that identify the present condition of the vehicle at a point in time.  The state variables are x position, y position, velocity, steering angle, cross track error, steering angle error.  These state variables are feed into the update equation, which then predicts what the future path of the vehicle needs to be in order to meet the desired path plan.  The future path plan, which can be visualized by the green line in the simulator, is generated from a set number of time steps and a time period between each time step.  A third order polynomial connects all points or timesteps to generate a path for the car to follow to get back to the desired path plan, which is indicated with the yellow line in my simulation.  Using our dymanic model of the vehicle and how we are able to actuate the vehicle to achieve the future path.  We then have to take the path and break that into actuation commands for the vehicle to execute.  I itially make the assumption that the first set of actuations to get the vehicle to the first point will be the only commands that will be valid for control as the future path will have to change to account for delays and error in system performance, which therefore means the actuations will have to change as well.  This means that with the future path point and the dynamic model, I can calculate using the dynamic equations the actuation commands the the next immediate step to drive the vehicle back on course.  The actuation commands are also affected not only by latency, which I will talk about below, but also cost.  This means that the determination of the next actuation is based on how expensive it is for the system to perform certain operations, like speeding up or slowing down, steering left or right, the rate at which the wheels are turned, and several other factors like how quick or slow the vehicle needs to get back to the desired path.  All these motions come at a cost to the system and this is accounted for in a calculated way to determine the "cheapest" or essentially fastest, smoothest, safest manner back to the desired path.  This is what the update function does it calculates future path, cost reduction of performing actuations to get back to desired path, and ultimately the desired actuations needed to get back to the desired path that is the fastest, smoothest, and safest way back to the path.  These actuation commands are values that are send to the actual actuators themselves that then control the vehicle.  In our case the actuators for the simulation are just the gas/brake or acceleration actuator and the steering actuator.   

Another critical feature of the program is the number of timesteps and the time difference dt between each actuation of the car controls.  This is a critical step of the program because if we have too many time steps to generate a smooth curve and too high a time difference between control actuations, then the program will not predict controls accurately or fast enough for sudden changes in the landscape of the driving terrain.  It should also be noted that if the dt is too small, then the car will actuate or change speed and steering commands too frequently and the control of the car will not be smooth and steady for the occupants of the vehicle.  I have tested several combinations, starting off with the suggested 25 steps and 0.05 time difference.  I found that this caused the car to react too slowly to changes in the driving terrain and caused the vehicle to crash.  I then tried a much lower number with 9 time steps like in the example lecture.  I tried a time difference of that go me a little under a 1 second prediction of control into the future.  I found that this step was slightly too responsive and caused the car to change control slightly too much.  I instead increased the number of timesteps to an even 10 and changed the time difference to get me to a little around 1 second control prediction into the future.  This project tip helped me to solidfy these values for my program.

The last part of my MPC program was to account for latency due to delayed control of the actuators to achieve the desired control path.  In order to account for this delay I had to incorporate a dynamic shift in the state values that were used to calculate the predicted future control. This meant adding in the vehicle change in current position and steering angle due to vehicle speed and delay time, as well as, present steering angle and delay time to account for the delay in actuation.  The last step for me to realize the latency portion of the program was to adjust the latency delay to account for how long it actually took to actuate the controls.  I accomplished this step by trial and error of the delay value itself.  This is how I incorporated latency into my model.  For more details on the exact equations used refer to the main.cpp file and within the main function itself under the latency comment are my equations used to address the issue.
